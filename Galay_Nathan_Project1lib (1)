.globl main 
.equ STDOUT, 1
.equ STDIN, 0
.equ __NR_READ, 63
.equ __NR_WRITE, 64
.equ __NR_EXIT, 93

.text

main:
//main() prolog
	addi sp, sp, -104
	sw ra, 100(sp)
  //main() prolog
    addi sp, sp, -104
    sw ra, 100(sp)

    la a0, prompt //Load the address of the prompt string
    call puts

    la a0, buffer //Load the address of the buffer
    call gets

    la a0, buffer //Load the address of the buffer to be printed
    call puts

    //main() epilog
    li a7, __NR_EXIT
    li a0, 0
    ecall

	//main() body
	
	
//methods

// reads the next character from stdin and returns it as an unsigned char cast to
// an int , or -1 on end of file or error 
getchar:
   li a7, __NR_READ //a7 now holds 63 or tells the computer to make a read system call
   li a0, STDIN //tells the system to read from stdin (keyboard) 
   la a1, buffer //the one character you want is stored in the buffer, so you pass the address of that one character to a1 so that string is read contiguously
   li a2, 1 //specifies reading one byte
   ecall //tell the system to do the instructions
   lb a0, 0(a1) //get the character from the buffer in memory allowing it to be used 
   ret //return it for use

// writes the character c , cast to an unsigned char , to stdout
// returns the same input unsigned char
putchar:
    addi sp, sp, -4         //Allocate space on the stack
    sb a0, 0(sp)             //Store the character on the stack
    li a7, __NR_WRITE        //a7 = system call number 64 for write
    li a0, STDOUT            //a0 = file descriptor for stdout
    mv a1, sp                //save the stack pointer to a1
    li a2, 1           //a2 = length of the string (1 byte)
    ecall                    //perform the system call
    addi sp, sp, 4           //Deallocate stack space
    ret


//gets is the function that reads from stdin

// reads a line from stdin into the buffer pointed to by s until a terminating
//newline .
// Returns the number of bytes read into the buffer , or -1 on error or end - of - file
//reached
// before reading a newline
gets:
   mv t0, a0 //save the address of the buffer in t0 so we can go back to it
   li t1, 0 //create a counter 
   
get_char_loop:
   call getchar //get a character from stdin
   mv t2, a0 //save character into t2
   blt t2, x0, gets_done //if -1 is found, branch to the end
   sb t2, 0(t0) //store the character in t2 at address t0
   addi t0, t0, 1 //incriment to the next character address
   addi t1, t1, 1 //incriment the counter
   
   li t3, 10 //the new line ASCII character stored in t3
   beq t2, t3, gets_done //if the character that is found is \n, branch to gets_done
  
   
   j get_char_loop //else jump back to the top of the loop
   
gets_done:
   sb zero, 0(t0) //implement the null character at the end of the string
   mv a0, t1 //return the number of characters read
   ret

//writes the string from the gets function recieved

// writes the string s appended with a trailing newline to stdout .
// Returns a nonnegative number on success , or -1 on error
//puts function
puts:
    mv t0, a0 //Save the address of the string
puts_loop:
    lb a0, 0(t0) //Load a character
    beqz a0, puts_newline //If null, go to newline
    call putchar
    blt a0, x0, puts_error //Check for putchar error
    addi t0, t0, 1 //Increment pointer
    j puts_loop

puts_newline:
    li a0, 10 //Load newline character
    call putchar
    blt a0, x0, puts_error
    li a0, 0
    ret

puts_error:
    li a0, -1
    ret
.data
prompt:   .ascii  "Enter a message: "
prompt_end:
buffer: .space 100 //allocate 1 byte of space for the buffer where a character will be stored

//the buffer is useful here:
//1: allows for the temporary storage of characters in contiguous memory
//2: complete a string using the null terminator
//3: treat inputs as a string
//4: control input size
